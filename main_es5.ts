/**
 * A script for Nginx-NJS to update Cloudflare DNS records.
 * Require SSL(https) support.
 * Remove `class` keyword to use in Nginx-NJS.
 * 
 * @copyright izGroup
 * @version 1.0.0
 * @license MIT
 */

/// <reference path="../type/index.d.ts" />
/// <reference path="../type/ngx_http_js_module.d.ts" />

interface Zone  {
    "id": string,
    "name": string,
    "status": "active" | "disabled",
    "paused": boolean,
    "type": "full" | "partial",
    "owner": Object,
    "account": Object,
    "permissions": Array<string>,
    "plan": Record<string, string | number>
}

interface DomainRecord {
    "id": string,
    "zone_id": string,
    "zone_name": string,
    "name": string,
    "type": "A" | "AAAA" | "CNAME" | "MX" | "NS" | "SRV" | "TXT",
    "content": string,
    "proxiable": boolean,
    "proxied": boolean,
    "ttl": number,
    "locked": boolean,
    "meta": {
        "auto_added": boolean,
        "managed_by_apps": boolean,
        "managed_by_argo_tunnel": boolean,
        "source": string
    },
    "comment": string | null,
    "tags": Array<string>,
    "created_on": string,
    "modified_on": string
}

interface CFError {
    code: number,
    message: string
}

type CFRootError = CFError & {
    error_chain: Array<CFError>
}

interface CFResult { 
    "success": boolean, 
    "errors": Array<CFRootError>,
    "messages": Array<string>,
    "result": null | Record<string, any> | Array<Record<string, any>>
}

interface ClassCFStruct{
    readonly token: string;
    findZone: (this: ClassCFStruct, name: string) => Promise<Zone>;
    findRecord: (this: ClassCFStruct, zone: Zone, name: string, type: string) => Promise<DomainRecord>;
    updateRecord: (this: ClassCFStruct, record: DomainRecord, value: string) => Promise<DomainRecord>;
    createRecord: (this: ClassCFStruct, zone: Zone, name: string, rrType: "A" | "AAAA", value: string, ttl?: number) => Promise<DomainRecord>;
    deleteRecord: (this: ClassCFStruct, record: DomainRecord) => Promise<void>;
    /**
     * @private
     */
    _fetchWithToken: (this: ClassCFStruct, endpoint: string, options: NgxFetchOptions) => Promise<CFResult>;
}

interface ClassCF{
    new(token: string): ClassCFStruct;
    cloudflare_url: string;
    anaError: (this: ClassCF, error: CFResult) => string;
    prototype: ClassCFStruct;
}

const Cloudflare = /** @class */ (function(): ClassCF{
    const Cloudflare = function(token: string) {
        this.token = token;
    } as any as ClassCF;

    Cloudflare.cloudflare_url = "https://api.cloudflare.com/client/v4";

    Cloudflare.anaError = function(res) {
        let text = '';
        for(let i = 0; i < res.errors.length; i++){
            const response = res.errors[i];
            text += `\n - ERROR ${response.code}: ${response.message}`;
            for(let i = 0; i < response.error_chain.length; i++){
                text += `\n    <- ${response.error_chain[i].code}: ${response.error_chain[i].message}`;
            }
        }
        return text;
    }

    Cloudflare.prototype.findZone = async function(name: string): Promise<Zone> {
        const body = await this._fetchWithToken(`zones?name=${name}`, {});
        if (!body.result || body.result.length === 0)
            throw new Error(`Failed to find zone '${name}'`);
        return body.result[0];
    };

    Cloudflare.prototype.findRecord = async function(zone: Zone, name: string, type: string): Promise<DomainRecord> {
        const body = await this._fetchWithToken(`zones/${zone.id}/dns_records?name=${name}`, {});
        if (!body.result || body.result.length === 0)
            throw new Error(`Failed to find dns record '${name}'`);
        return (body.result as Array<DomainRecord>).filter(rr => rr.type === type)[0];
    };

    Cloudflare.prototype.updateRecord = async function(record: DomainRecord, value: string) {
        record.content = value;
        const body = await this._fetchWithToken(
            `zones/${record.zone_id}/dns_records/${record.id}`,
            {
                method: "PUT",
                body: JSON.stringify(record),
            }
        );
        if (!body.result || body.result.length === 0)
            throw new Error("Failed to update dns record");
        return body.result[0];
    };

    Cloudflare.prototype.createRecord = async function(zone: Zone, name: string, rrType: "A" | "AAAA", value: string, ttl): Promise<DomainRecord> {
        const result = await this._fetchWithToken(
            `zones/${zone.id}/dns_records`,
            {
                method: "POST",
                body: JSON.stringify({
                    type: rrType,
                    name,
                    content: value,
                    ttl: ttl || 60,
                    proxied: false,
                    comment: "Generated by nginx-njs"
                })
            }
        );
        if (!result.result)
            throw new Error("Failed to create dns record");
        return result.result as DomainRecord;
    };

    Cloudflare.prototype.deleteRecord = async function(record: DomainRecord) { 
        const result = await this._fetchWithToken(
                `zones/${record.zone_id}/dns_records/${record.id}`,
                {
                    method: "DELETE"
                }
            );
        if (!result.success)
            throw new Error("Failed to delete dns record");
    };

    Cloudflare.prototype._fetchWithToken = async function(endpoint: string, options: NgxFetchOptions) {
        const url = `${Cloudflare.cloudflare_url}/${endpoint}`;
        if(!options.headers) options.headers = {};
        options.headers['Content-Type'] = 'application/json';
        options.headers['Authorization'] = `Bearer ${this.token}`;
        const xhr = await ngx.fetch(url, options),
            json = await xhr.json() as CFResult;
        if(!xhr.ok || !json.success)
            throw new Error(Cloudflare.anaError(json));
        return json;
    };

    return Cloudflare as any;
})();

async function update(h: NginxPeriodicSession){
    // 读取环境变量
    const user_token = h.variables.ddns_cf_token,
        domain = h.variables.ddns_cf_domain,
        record_name = h.variables.ddns_cf_record_name,
        record_type = h.variables.ddns_cf_record_type,
        ipapi = h.variables.ddns_ipapi;

    if(!user_token || !domain || !record_name || !record_type || !ipapi)
        throw new Error("Missing required parameters");

    const ddns = new Cloudflare(user_token);

    // 尝试寻找缓存
    if('ddns_cache' in h.variables){
        const _key = (h.variables.ddns_cache as string).split('.'),
            zone_name = _key[0],
            key = _key[1];
        if(zone_name in ngx.shared){
            // 有缓存
            if(ngx.shared[zone_name].has(key)){
                const cache = JSON.parse(ngx.shared[zone_name].get(key) as string);
                var zone = cache.zone as Zone,
                    record = cache.record as DomainRecord;
            }else{
                var zone = await ddns.findZone(domain),
                    record = await ddns.findRecord(zone, record_name, record_type);
                ngx.log(ngx.INFO, `Cache miss for ${zone.name}`);
            }
        }else{
            throw new Error("Failed to find cacheZone");
        }
    }else{
        var zone = await ddns.findZone(domain),
            record = await ddns.findRecord(zone, record_name, record_type);
        ngx.log(ngx.WARN, `WARN! Cache was disabled, please enable it to improve performance`);
    }

    // 获取新IP
    const ip = await (await ngx.fetch(ipapi)).text();

    // 更新记录
    if(record.content !== ip){
        record = await ddns.updateRecord(record, ip);
        ngx.log(ngx.INFO, `Updated ${record.name}.${zone.name} (${record.type}) to ${ip}`);
    }else{
        ngx.log(ngx.INFO, `No need to update ${record.name}.${zone.name} (${record.type}) to ${ip}`);
    }

    // 更新缓存
    const _key = (h.variables.ddns_cache || '').split('.'),
        zone_name = _key[0],
        zone_key = _key[1];
    if( zone_name && zone_key &&
        ((!ngx.shared[zone_name].has(zone_key)) || ip !== record.content)
    ){
        const cache = {zone, record};
        ngx.shared[zone_name].set(zone_key, JSON.stringify(cache));
        ngx.log(ngx.INFO, `Cache updated for ${zone.name}`);
    }
}

function statusHTML(h: NginxHTTPRequest){
    h.headersOut['Content-Type'] = 'text/plain';
    if(!h.variables.ddns_cache) return h.return(500, "No cache found");
    const _key = (h.variables.ddns_cache as string).split('.'),
        cache_zone = _key[0],
        cache_key = _key[1];

    if(cache_zone in ngx.shared && ngx.shared[cache_zone].has(cache_key)){
        const cache = JSON.parse(ngx.shared[cache_zone].get(cache_key) as string);
        const zone = cache.zone as Zone,
            record = cache.record as DomainRecord;
        h.return(200, `这是你的域名详细信息，请查收
域名：${record.name}.${zone.name} (${record.type})
上一次更新: ${record.modified_on}
记录值: ${record.content}`);
    }else{
        return h.return(500, "Failed to find cache");
    }
}

export default { 
    main: (h: NginxPeriodicSession) => update(h).catch(e => ngx.log(ngx.ERR, `Thread exited unexpectedly: ${new String(e)}`)),
    status: (h: NginxHTTPRequest) => statusHTML(h)
}